import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Test {
	private String output_folder = "";
	private String nuXMV_file = "nuXmv";
	private List<List<Integer>> scenarios = new ArrayList<List<Integer>>();
	private List<String> scenario_files = new ArrayList<String>();
	private int lprop_number;
	private int cprop_number;
	final int OBL_DEP = 14; // dependency. this must be 0 for independent modules
	final int POW_DEP = 22; // this must be 0 for independent modules
      // number of 0 to  2^ pow, 2^obligation-- max_obls
     // number of 0 to  2^ pow--max_pows
	Test(int max_obls, int max_pows, int lpnum, int cpnum) {
		lprop_number = lpnum; //number of LTL properties you want to generate and verify;
		cprop_number = cpnum; //number of CTL properties you want to generate and verify; one of the generated ctl:=1
		//generate test scenarios (obligation#, power#, obligation dependency rate, power dependency rate) 
		for(int o=0; o<=max_obls; o++) {  // int o=4; o<=max_obls; o++
			for(int p=0; p<=max_pows; p++) { // int p=0; p<=max_pows; p++     int p=4; p<=4; p++
				scenarios.add(Arrays.asList((int)Math.pow(2,o), (int)Math.pow(2,p),OBL_DEP,POW_DEP));
			}
		}
	}

	public void generate() throws IOException, InterruptedException {
		System.out.println("Writting .ord files in " + output_folder);
		
		for(int i=0; i<scenarios.size(); i++) {
		System.out.println("scenarios.get(i)" + scenarios.get(i).get(0));
			Contract cnt = new Contract(scenarios.get(i).get(0), scenarios.get(i).get(1), scenarios.get(i).get(2), scenarios.get(i).get(3));
			LtlGenerator ltl_gen = new LtlGenerator(scenarios.get(i).get(0), scenarios.get(i).get(1), lprop_number);
			CtlGenerator ctl_gen = new CtlGenerator(scenarios.get(i).get(0), scenarios.get(i).get(1), cprop_number);
			String generic_modules = read_generic_modules("TestContract"+scenarios.get(i).get(0)+"o"+scenarios.get(i).get(1)+"p"+scenarios.get(i).get(2)+"od"+scenarios.get(i).get(3)+"pd.smv");
			// ltl_gen.get() and  ctl_gen.get(): To generate LTL or CTL properties and combine them with the test modules (generic_modules) that are generated by SymboleoPC and saved in the same folder that this test.java is saved inside. 
			// cnt.get(): we used it to generate obligations and powers with the specified dependency. Then we simulate the same dependency using SymboleoPC and generate the smv module (generic model).
			// after that we used: String content = generic_modules; to copy the module that is generated by SymboleoPC only and generate the workspace. To test the LTL properties to verify them we used: String content = generic_modules+ ltl_gen.get(); 
			//String content = generic_modules + cnt.get() + ltl_gen.get() + ctl_gen.get();
			String content = generic_modules+ ltl_gen.get();
			//  String content = generic_modules;
		    System.out.println("read_generic= " + "TestContract"+scenarios.get(i).get(0)+"o"+scenarios.get(i).get(1)+"p"+scenarios.get(i).get(2)+"od"+scenarios.get(i).get(3)+"pd.smv");
			scenario_files.add(output_folder+"/TestContract"+scenarios.get(i).get(0)+"o"+scenarios.get(i).get(1)+"p"+scenarios.get(i).get(2)+"od"+scenarios.get(i).get(3)+"pd");
			write_in_file(content, scenario_files.get(scenario_files.size()-1)+".smv");
			//write_in_file(content, scenario_files.get(scenario_files.size()-1)+".smv");
			Thread.sleep(200);
		}
		System.out.println("Wrote in " + output_folder);
	}

	public void run() throws IOException, InterruptedException {
		String command_file1 = output_folder+"/commands1.txt";
		String command_file2 = output_folder+"/commands2.txt";
		String pathToCCsv = output_folder+"/combinedresult.csv";
		String pathToOCsv = output_folder+"/orderresult.csv";
		String pathToRCsv = output_folder+"/reachresult.csv";	
		String command = "";
		String ltlvar = "";
		FileWriter csvCWriter = new FileWriter(pathToCCsv);
		FileWriter csvOWriter = new FileWriter(pathToOCsv);
		FileWriter csvRWriter = new FileWriter(pathToRCsv);
		csvCWriter.append("obligation#, power#, obligation dependency%, power dependency%, elapse time, total time, formula\n");
		csvOWriter.append("obligation#, power#, obligation dependency%, power dependency%, elapse time, total time, formula\n");
		csvRWriter.append("obligation#, power#, obligation dependency%, power dependency%, elapse time, total time, formula\n");

		for(int sc=0; sc<scenario_files.size(); sc++) {
			ProcessBuilder pb = new ProcessBuilder();
			System.out.println("process smv file");	        
			// if you want to use check_ltlspec_ic3  algorithm let commands as follows:
			String commands = "\ngo_msat \n";
			  // if you want to use check_ltlspec or check_ctlspec algorithms let commands as follows:
			//String commands = "# unset forward_search \n # dynamic_var_ordering -e sift \n set input_order_file "+ scenario_files.get(sc)+".ord\ngo \n go_msat \n";
        for (int i = 0; i < lprop_number; i++) {
            commands += "\n check_ltlspec_ic3 -i -d  -n " + i + "\n time \n"; 
			// If you want to use check_ltlspec or check_ctlspec algorithms, use one of the following instead of the last line
			// "\ncheck_ltlspec -P LTL" + i + " \n time \n"
			// " check_ctlspec -P CTL" + i + " \n time \n";
 
        }

        commands += "  \nquit";

        try {
            FileWriter fileWriter = new FileWriter(command_file2);
            fileWriter.write(commands);
            fileWriter.close();
            System.out.println("Commands written to commands2.txt");
        } catch (IOException e) {
            e.printStackTrace();
        }
		Thread.sleep(500);
			//write_in_file(command, command_file2);	
System.out.println("./"+nuXMV_file +" -cpp -v 0 -load "+ command_file2 +" "+scenario_files.get(sc)+".smv" );			
			pb.command("bash", "-c", "./"+nuXMV_file +" -int -dcx -cpp -v 0 -load "+ command_file2 +" "+scenario_files.get(sc)+".smv" );			
	
					
			System.out.println("bash "+ "-c"+ " ./"+nuXMV_file + " -source " + command_file1);
			String line;
			Process ps = pb.start();
			StringBuilder output = new StringBuilder();
			StringBuilder output2 = new StringBuilder();
			BufferedReader reader = new BufferedReader(
	                new InputStreamReader(ps.getInputStream()));
			int cntc=0;
	        while ((line = reader.readLine()) != null) {
				System.out.println("\n LineInloop"+cntc+line+"\n");
				if (line.contains("elapse:")) {
					output.append(line + "\n");
					//if (cntc>0)output.append(line + "\n");
					
					
					}
					if (line.contains("specification")) {
					output2.append(cntc+line + "\n");
					//if (cntc>0)output.append(line + "\n");
					cntc++;
					
					}
					
	            

	        }
	        
	        int exitVal = ps.waitFor();
	        if (exitVal == 0) {
				System.out.println("\n"+scenario_files.get(sc)+"\n");
	            System.out.println("Success!");
	            System.out.println(output);
	            String[] lines = output.toString().split("\n");
				String[] lines2 = output2.toString().split("\n");
				
				cntc=0;
				for (String lin : lines) {
				System.out.println("print===="+lin); // Or perform any other operation on each line
                System.out.println("print====result: "+lin.toString());
	            String result = lin.replace("elapse:", "").replace("seconds", "").replace("total:", "");
				System.out.println("print====result: "+result+lines2.toString());
	            String[] stimes = result.split(",");
	            float[] times = {0,0};
				System.out.println("print====stimes: "+stimes[0]+" "+stimes[1]);
				//record reach computing execution time
				csvRWriter.append(scenarios.get(sc).get(0).toString()+",").append(scenarios.get(sc).get(1).toString()+",")
	            .append(scenarios.get(sc).get(2).toString() +",").append(scenarios.get(sc).get(3).toString() +",")
	            .append(stimes[0]+",").append(stimes[1]+",").append(lines2[cntc].toString()+"\n");
				
				//record total time(ordering and reach computing time)
	            times[0] = Float.parseFloat(stimes[0]) ;
	            times[1] = Float.parseFloat(stimes[1]) ;
	            csvCWriter.append(scenarios.get(sc).get(0).toString()+",").append(scenarios.get(sc).get(1).toString()+",")
	            .append(scenarios.get(sc).get(2).toString() +",").append(scenarios.get(sc).get(3).toString() +",")
	            .append(Float.toString(times[0])+",").append(Float.toString(times[1])+",").append(lines2[cntc].toString()+"\n");
				cntc++;
				}
	        } else {
	        	System.out.println("Error!");
	        }
		
		}
		csvCWriter.flush();
		csvOWriter.flush();
		csvRWriter.flush();
		csvCWriter.close();
		csvOWriter.close();
		csvRWriter.close();
		System.exit(0);
	}
	
	public void set_output_folder(String path) {
		output_folder = path;
	}
	
	public void set_nuxmv_file(String path) {
		nuXMV_file = path;
	}
	
	private String read_generic_modules(String gen) throws IOException {
		String content = "";
		//InputStream reader = Test.class.getResourceAsStream("/generic_smv_modules.txt"); "generic_smv_modules.txt"
		File gmodule = new File(gen);
		InputStream reader = new FileInputStream(gen);
		try {
			content = stream_to_string(reader);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}		
		return content;
	}
	
	private String stream_to_string(InputStream aInInputStream)
    		throws IOException {
        ByteArrayOutputStream byteArrayOutputStream =
        		new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int length;
        while ((length = aInInputStream.read(buffer)) != -1) {
            byteArrayOutputStream.write(buffer, 0, length);
        }
        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());
    }
	
	private void write_in_file(String content, String output_file) throws IOException {
		FileWriter smvFile = new FileWriter(output_file);
		smvFile.write(content);
		smvFile.close();		
	}
}
